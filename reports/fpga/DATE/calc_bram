Como exemplo, tomou-se o FPGA Xilinx VU9P como base, que possui aproximadamente 2,5 milhões de \glspl{LUT}, 6800 blocos de \glspl{DSP} e 2160 blocos de memória \gls{B-RAM}, o que totaliza cerca de 7,9 MB de armazenamento interno~\cite{xilinx2020ultrascale}. Para o circuito \textit{div}, a matriz de LUT possui aproximadamente $100 \times 100$ posições (considerando apenas a quantidade de nós). Portanto é necessário, no mínimo, 14 bits para endereçar até $2^{14} = 16.384$ posições — quantidade suficiente para representar os 10.000 índices da matriz. Adicionalmente, são requeridos mais 14 bits para armazenar a identificação dos nós associados a cada posição, portanto  28 bits por vértice/posição.

Dessa forma, para a implementação das estruturas de memória $N_2C$ e $C_2N$, responsáveis por armazenar as associações entre os nós do grafo e as células da matriz de posicionamento irá alocar no mínimo 28 blocos (\gls{B-RAM}), que  possuem a capacidade aproximada de 30 K bits. Portanto é possível armazenar a demanda das 10.000 posições do circuito \textit{div}.

Considerando a execução do algoritmo \gls{SA} operando com ao menos dez \textit{threads} em paralelo, cada uma com conjuntos de dados independentes, o volume total de armazenamento necessário aumenta proporcionalmente. Nesse caso, seriam necessárias $10 \times 10.000 = 100.000$ posições para cada uma das memórias $N_2C$ e $C_2N$, o que corresponde a $\frac{100.000}{30.000} \approx 4$; e $4 \times 28 \approx 112$ blocos \gls{B-RAM} para as duas memórias (56 blocos para cada uma).

Adicionalmente é necessário contabilizar também a memória para a lista de adjacências do circuito. Assumindo que cada nó possue até  quatro conexões com outros nós, são necessários aproximadamente $4 \times 14 = 56$ blocos de memória \gls{B-RAM} para armazenar os identificadores dos nós adjacentes para uma matriz com 10.000 elementos.

Importante ressaltar que na arquitetura em \textit{pipeline} do algoritmo \gls{SA}, a memória $N_2C$ precisa ser replicada $v$ vezes, onde $v$ é o número máximo de vizinhos de um nó, uma vez que múltiplas leituras simultâneas dessa estrutura são necessárias em um mesmo estágio do \textit{pipeline}. Sendo assim, seriam requeridas quatro instâncias independentes de $N_2C$; isso resulta em um consumo adicional de $4 \times 56 = 224$ blocos \gls{B-RAM}.

Somando-se aos 56 blocos necessários para $C_2N$ e aos 56 blocos para a memória de adjacências (\textit{Viz}),  a implementação de uma única instância do circuito, com dez \textit{threads}, consume no mínimo 336 blocos \gls{B-RAM}, que corresponde a aproximadamente 15\% do total de blocos. O resumo dos cálculos pode ser visto na Tabela~\ref{table:fpga_poss_bram}. É importante destacar que esse cálculo refere-se a uma única cópia do \textit{pipeline}. Para uma maior exploração com a utilização de cópias do circuito ou um maior número de \textit{threads}, a utilização de blocos \gls{B-RAM} cresce proporcionalmente e, por exemplo, com seis cópias, a utilização pode ultrapassar os 90\% dos blocos disponíveis.

O consumo estimado de recursos para as implementações dos algoritmos \gls{YOTO} e \gls{YOTT} em \gls{FPGA} segue uma metodologia de cálculo semelhante àquela utilizada para o algoritmo \gls{SA}, descrita anteriormente. Para fins de comparação direta, consideram-se, nesta análise, arquiteturas com 10 \textit{threads} por instância.

As estruturas de memória $N_2C$ e $C_2N$, responsáveis por armazenar as associações entre nós e células da matriz de posicionamento, são mantidas nos algoritmos \gls{YOTO} e \gls{YOTT}. Cada uma dessas estruturas requer aproximadamente 56 blocos \gls{B-RAM}, totalizando 112 blocos para ambas.

Ao contrário do algoritmo \gls{SA}, que utiliza uma memória de adjacências, os algoritmos \gls{YOTO} e \gls{YOTT} operam diretamente sobre uma estrutura de arestas explícitas. Essa estrutura armazena pares de nós $(u, v)$ que representam as conexões direcionadas do grafo. Sendo 14 bits para a codificação de cada identificador de nó, cada aresta requer 28 bits. Com base no \textit{benchmark div} que possui aproximadamente 30.000 arestas, a estrutura consume aproximadamente 28 blocos \gls{B-RAM}, o que totaliza $112 + 28 = 140$ blocos para a implementação completa do \gls{YOTO}. Este valor corresponde a aproximadamente 7\% do total de blocos de memória disponíveis.


